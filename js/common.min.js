"use strict";

class WeatherTable {
    constructor(weatherObject) {
        const table = document.createElement("table");
        const tbody = document.createElement("tbody");
        const options = [ "temp_c", "feelslike_c", "humidity", "precip_mm", "pressure_mb", "cloud", "wind_kph" ];
        let tr;
        let th;
        let td;
        table.className = "Weather-table";
        table.appendChild(tbody);
        options.forEach(el => {
            if (weatherObject[el] !== undefined) {
                tr = document.createElement("tr");
                th = document.createElement("th");
                td = document.createElement("td");
                th.innerText = this.constructor.parseProperty(el);
                td.innerText = weatherObject[el];
                tr.appendChild(th);
                tr.appendChild(td);
                tbody.appendChild(tr);
            }
        });
        return table;
    }
    static parseProperty(property) {
        switch (property) {
          case "temp_c":
            return "Temperature, °C";

          case "feelslike_c":
            return "Temperature feels like, °C";

          case "humidity":
            return "Humidity, %";

          case "precip_mm":
            return "Precip, mm";

          case "pressure_mb":
            return "Pressure, mb";

          case "cloud":
            return "Cloud cover, %";

          case "wind_kph":
            return "Wind speed, KPH";
        }
    }
}

class Popup {
    constructor({shadowID: shadowID = false, shadowType: shadowType = "transparent", closeButton: closeButton = true, closeText: closeText = false, popupName: popupName = "popup", popupClass: popupClass = "Popup", popupCaption: popupCaption = "", customBody: customBody = false, bodyElement: bodyElement = null}) {
        if (document.querySelector(`[data-popup=${popupName}]`)) {
            document.querySelector(`[data-popup=${popupName}]`).remove();
        }
        let shadow;
        let popupTitle;
        let popupCloseText;
        let popupCloseButton;
        const popup = document.createElement("div");
        document.body.appendChild(popup);
        popup.className = popupClass;
        popup.dataset.popup = "" + popupName;
        if (shadowID) {
            shadow = document.getElementById(shadowID);
            shadow.classList.add("active");
        }
        if (popupCaption) {
            popupTitle = document.createElement("p");
            popupTitle.innerText = popupCaption;
            popupTitle.className = popupClass + "-title";
            popup.appendChild(popupTitle);
        }
        if (closeButton) {
            let closeButtonIcon = `<svg class="${popupClass}-closeButtonIcon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 475.2 475.2" style="enable-background:new 0 0 475.2 475.2;" xml:space="preserve"> <g> <g> <path d="M405.6,69.6C360.7,24.7,301.1,0,237.6,0s-123.1,24.7-168,69.6S0,174.1,0,237.6s24.7,123.1,69.6,168s104.5,69.6,168,69.6 s123.1-24.7,168-69.6s69.6-104.5,69.6-168S450.5,114.5,405.6,69.6z M386.5,386.5c-39.8,39.8-92.7,61.7-148.9,61.7 s-109.1-21.9-148.9-61.7c-82.1-82.1-82.1-215.7,0-297.8C128.5,48.9,181.4,27,237.6,27s109.1,21.9,148.9,61.7 C468.6,170.8,468.6,304.4,386.5,386.5z"/> <path d="M342.3,132.9c-5.3-5.3-13.8-5.3-19.1,0l-85.6,85.6L152,132.9c-5.3-5.3-13.8-5.3-19.1,0c-5.3,5.3-5.3,13.8,0,19.1 l85.6,85.6l-85.6,85.6c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4l85.6-85.6l85.6,85.6c2.6,2.6,6.1,4,9.5,4 c3.5,0,6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1l-85.4-85.6l85.6-85.6C347.6,146.7,347.6,138.2,342.3,132.9z"/> </g> </g> </svg>`;
            closeButtonIcon = this.constructor.toHTML(closeButtonIcon);
            popupCloseButton = document.createElement("button");
            popupCloseButton.className = popupClass + "-closeButton";
            popupCloseButton.dataset.popupClose = "" + popupName;
            popupCloseButton.appendChild(closeButtonIcon);
            popup.appendChild(popupCloseButton);
            popupCloseButton.addEventListener("click", this.closeCurrentPopup);
        }
        if (customBody && this.constructor.isHTML(bodyElement)) {
            popup.appendChild(bodyElement);
        }
        if (closeText) {
            popupCloseText = document.createElement("p");
            popupCloseText.className = popupClass + "-closeText";
            popupCloseText.innerHTML = closeText;
            popupCloseText.dataset.popup = "close";
        }
        return popup;
    }
    closeCurrentPopup(e) {
        const popupName = e.currentTarget.dataset.popupClose;
        const popup = e.currentTarget.closest(`[data-popup=${popupName}`);
        popup.classList.remove("active");
    }
    static isHTML(element) {
        try {
            return element instanceof HTMLElement;
        } catch (e) {
            return typeof obj === "object" && element.nodeType === 1 && typeof element.style === "object" && typeof element.ownerDocument === "object";
        }
    }
    static toHTML(string) {
        const container = new DOMParser().parseFromString(string, "text/xml");
        return container.firstChild;
    }
}

function activateAutocomplete() {
    const input = document.querySelector("[data-input=cities-search-weather]");
    const lastSearchCity = localStorage.getItem("lastWeatherSearchCity");
    const lastSearchGeometry = localStorage.getItem("lastWeatherSearchGeometry");
    const options = {
        types: [ "(cities)" ],
        fields: [ "name", "geometry" ]
    };
    const autocomplete = new google.maps.places.Autocomplete(input, options);
    autocomplete.setFields();
    autocomplete.addListener("place_changed", () => {
        const place = autocomplete.getPlace();
        input.geometry = `${place.geometry.location.lat()},${place.geometry.location.lng()}`;
    });
    input.value = localStorage.getItem("lastWeatherSearchCity");
    input.geometry = localStorage.getItem("lastWeatherSearchGeometry");
}

(function activateWeatherSearch() {
    const cityWeatherForm = document.querySelector('[data-form="city-weather"');
    const cityWeatherIconElem = document.querySelector('[data-container="city-weather"] > i');
    cityWeatherIconElem.addEventListener("click", showWeatherSearchForm);
    cityWeatherForm.addEventListener("submit", getForecast);
    cityWeatherForm.addEventListener("keypress", e => {
        if (e.keyCode === 13) {
            e.preventDefault();
        }
    });
})();

function showWeatherSearchForm(e) {
    e.currentTarget.parentElement.classList.add("active");
}

function validateCityText() {
    const input = document.querySelector('[data-input="cities-search-weather"');
    const re = /^[a-z, .-]*$/i;
    const errorMessage = document.createElement("span");
    errorMessage.className = "Header-weatherError";
    if (!re.test(input.value)) {
        errorMessage.innerHTML = "English letters only!";
        input.parentElement.appendChild(errorMessage);
        setTimeout(() => input.parentElement.removeChild(errorMessage), 4e3);
        return false;
    }
    return true;
}

function getForecast(e) {
    e.preventDefault();
    if (validateCityText()) {
        const input = document.querySelector("[data-input=cities-search-weather]");
        const place = input.value;
        let searchGeometry = input.geometry;
        let searchCity = place.trim().split(" ", 1).join().split(",", 1).pop();
        fetch(`https://api.apixu.com/v1/current.json?key=3188df048e8949a397b180202191902&q=${searchGeometry ? searchGeometry : searchCity}`).then(response => {
            if (response.ok) {
                input.value = "";
                input.geometry = "";
                localStorage.setItem("lastWeatherSearchCity", place);
                localStorage.setItem("lastWeatherSearchGeometry", searchGeometry);
                return response.json();
            } else {
                throw Error(response.statusText);
            }
        }).then(result => {
            renderWeatherPopup(place, result.current);
        }).catch(error => {
            alert(`Somehow, your incorrect text pass form validation, but server smarter and he return error. Error code is - ${error.message}`);
        });
    }
}

function renderWeatherPopup(place, data) {
    const weatherBlock = document.createElement("div");
    const weatherTitle = document.createElement("p");
    const weatherCondition = document.createElement("p");
    const weatherTable = new WeatherTable(data);
    let weatherPopup;
    weatherBlock.className = "Weather";
    weatherTitle.className = "Weather-title";
    weatherCondition.className = "Weather-condition";
    weatherTitle.innerText = place;
    weatherCondition.innerText = "Weather condition: " + data.condition.text + ".";
    weatherBlock.appendChild(weatherTitle);
    weatherBlock.appendChild(weatherCondition);
    weatherBlock.appendChild(weatherTable);
    weatherPopup = new Popup({
        shadowID: "shadow",
        customBody: true,
        popupName: "forecast",
        bodyElement: weatherBlock
    });
    setTimeout(() => weatherPopup.classList.add("active"), 10);
}

"use strict";

document.querySelector('#Menu li.Menu-item[data-work="14"]').addEventListener("click", renderHW_14);

document.querySelector('#Menu--tablet li.Menu-item[data-work="14"]').addEventListener("click", renderHW_14);

const HW_14 = {
    task1: {
        taskItem: "",
        render: function() {
            HW_14.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            let taskContainer = document.createElement("div");
            let caption = document.createElement("h4");
            let paragraphsText = [ "Написать функцию кеша, которая принимает два аргумента.", "Если такие аргументы ранее использовались - получить их из кеша. Если нет - записать в кеш и вернуть результат.", "Функцию можно вызвать из консоли: cache(arg1,arg2)" ];
            let paragraph;
            let i;
            let cache = document.createElement("p");
            let result = document.createElement("p");
            cache.dataset.role = "cache";
            cache.className = "Task-text";
            result.dataset.role = "result";
            result.className = "Task-text";
            let form = document.createElement("form");
            let row = document.createElement("div");
            let mediaContainer;
            let input;
            let inputCaptionText = [ "Argument #1:", "Argument #2:" ];
            let inputsPlaceholders = [ "Number or text", "Number or text" ];
            let label;
            let inputCaption;
            form.setAttribute("action", "#");
            form.id = "Cache";
            row.className = "row";
            form.appendChild(row);
            for (i = 0; i < 3; i++) {
                mediaContainer = document.createElement("div");
                mediaContainer.className = i !== 2 ? "cell-5 cell-ml" : "cell-2 cell-ml";
                input = document.createElement("input");
                if (i !== 2) {
                    label = document.createElement("label");
                    input.setAttribute("type", "text");
                    input.setAttribute("placeholder", inputsPlaceholders[i]);
                    input.className = "Task-input";
                    inputCaption = document.createElement("span");
                    inputCaption.className = "Task-text Task-text--decorated";
                    inputCaption.innerText = inputCaptionText[i];
                    label.appendChild(inputCaption);
                    label.appendChild(input);
                    mediaContainer.appendChild(label);
                } else {
                    input.setAttribute("type", "submit");
                    input.setAttribute("value", "Generate");
                    input.className = "Button Button-submit";
                    mediaContainer.appendChild(input);
                }
                row.appendChild(mediaContainer);
            }
            taskContainer.classList.add("Task-container");
            caption.classList.add("Task-title");
            caption.innerText = "Задача №1";
            taskContainer.appendChild(caption);
            for (i = 0; i < paragraphsText.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphsText[i];
                taskContainer.appendChild(paragraph);
            }
            taskContainer.appendChild(form);
            taskContainer.appendChild(cache);
            taskContainer.appendChild(result);
            renderArea.appendChild(taskContainer);
            this.cacheFunction = this.makeCache(this.complexFunction);
            form.addEventListener("submit", this.cacheFunction.bind(this));
            this.taskItem = taskContainer;
        },
        cache: [],
        complexFunction: function(a, b) {
            return a + b;
        },
        makeCache: function(func) {
            return function(event) {
                event.preventDefault();
                const formData = document.getElementsByClassName("Task-input");
                const cacheParagraph = document.querySelector('p[data-role="cache"]');
                const resultParagraph = document.querySelector('p[data-role="result"]');
                let arg1Value = formData[0].value;
                let arg2Value = formData[1].value;
                let arg1IsMatch;
                let arg2IsMatch;
                let cachedResult;
                let result;
                let i;
                arg1Value = isFinite(arg1Value) ? +arg1Value : arg1Value;
                arg2Value = isFinite(arg2Value) ? +arg2Value : arg2Value;
                formData[0].value = "";
                formData[1].value = "";
                if (typeof arg1Value === "number" && typeof arg2Value === "number") {
                    for (i = 0; i < this.cache.length; i++) {
                        cachedResult = this.cache[i];
                        arg1IsMatch = cachedResult[0] === arg1Value;
                        if (!arg1IsMatch) {
                            arg1IsMatch = cachedResult[0] === arg2Value;
                            arg2IsMatch = cachedResult[1] === arg1Value;
                        } else {
                            arg2IsMatch = cachedResult[1] === arg2Value;
                        }
                        if (arg1IsMatch && arg2IsMatch) {
                            result = cachedResult[2];
                            break;
                        }
                    }
                } else {
                    for (i = 0; i < this.cache.length; i++) {
                        cachedResult = this.cache[i];
                        if (cachedResult[0] === arg1Value && cachedResult[1] === arg2Value) {
                            return cachedResult[2];
                        }
                    }
                }
                if (result === undefined) {
                    result = func(arg1Value, arg2Value);
                    this.cache.push([ arg1Value, arg2Value, result ]);
                }
                console.log(this.cache);
                cacheParagraph.innerText = `Current cache is : ${this.cache}`;
                resultParagraph.innerText = `Result of operation is: ${result}`;
            };
        }
    },
    task2: {
        taskItem: "",
        render: function() {
            HW_14.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            let taskContainer = document.createElement("div");
            let caption = document.createElement("h4");
            let paragraphsText = [ "Создать форму которая содержит 2 инпута в которые вводятся размеры таблицы.", "По клику на ячейку она должна показывать свой индекс. Индекс нельзя хранить в разметке." ];
            let paragraphs = [];
            let paragraph;
            let i;
            let form = document.createElement("form");
            let row = document.createElement("div");
            let mediaContainer;
            let input;
            let inputCaptionText = [ "Columns:", "Rows:" ];
            let inputsPlaceholders = [ "Enter columns quantity", "Enter rows quantity" ];
            let label;
            let inputCaption;
            let btnWrapper = document.createElement("div");
            btnWrapper.className = "Button-submitWrapper";
            for (i = 0; i < 2; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphsText[i];
                paragraphs.push(paragraph);
            }
            form.setAttribute("action", "#");
            form.id = "TableGenerator";
            row.className = "row";
            form.appendChild(row);
            for (i = 0; i < 3; i++) {
                mediaContainer = document.createElement("div");
                mediaContainer.className = i !== 2 ? "cell-5 cell-ml-6" : "cell-2 cell-ml";
                input = document.createElement("input");
                if (i !== 2) {
                    label = document.createElement("label");
                    input.setAttribute("type", "number");
                    input.setAttribute("placeholder", inputsPlaceholders[i]);
                    input.className = "Task-input";
                    inputCaption = document.createElement("span");
                    inputCaption.className = "Task-text Task-text--decorated";
                    inputCaption.innerText = inputCaptionText[i];
                    label.appendChild(inputCaption);
                    label.appendChild(input);
                    mediaContainer.appendChild(label);
                } else {
                    input.setAttribute("type", "submit");
                    input.setAttribute("value", "Generate");
                    input.className = "Button Button-submit";
                    btnWrapper.appendChild(input);
                    mediaContainer.appendChild(btnWrapper);
                }
                row.appendChild(mediaContainer);
            }
            taskContainer.classList.add("Task-container");
            caption.classList.add("Task-title");
            caption.innerText = "Задача №2";
            taskContainer.appendChild(caption);
            taskContainer.appendChild(paragraphs[0]);
            taskContainer.appendChild(paragraphs[1]);
            taskContainer.appendChild(form);
            form.addEventListener("submit", HW_14.task2.renderTable.bind(HW_14.task2));
            renderArea.appendChild(taskContainer);
            this.taskItem = taskContainer;
        },
        renderTable: function(e) {
            e.preventDefault();
            const taskContainer = document.querySelector("#Content-area > .Task-container");
            const tableContainer = document.getElementById("Table-container") || document.createElement("div");
            const tableData = document.getElementsByClassName("Task-input");
            tableContainer.id = "Table-container";
            let table = document.createElement("table");
            let columns = +tableData[0].value;
            let rows = +tableData[1].value;
            let tr;
            let td;
            let i;
            let j;
            tableData[0].value = "";
            tableData[1].value = "";
            if (tableContainer.firstChild) {
                tableContainer.removeChild(tableContainer.firstChild);
            }
            if (Number.isFinite(columns) && Number.isFinite(rows) && columns < 20) {
                for (i = 0; i < rows; i++) {
                    tr = document.createElement("tr");
                    for (j = 0; j < columns; j++) {
                        td = document.createElement("td");
                        td.innerText = `${i} - ${j}`;
                        tr.appendChild(td);
                    }
                    table.appendChild(tr);
                }
                tableContainer.appendChild(table);
                taskContainer.appendChild(tableContainer);
            } else {
                alert("Введены некорректные данные");
                return;
            }
            table.onclick = HW_14.task2.getCellPosition;
            this.taskItem = taskContainer;
        },
        getCellPosition: function(e) {
            alert(`row - ${e.target.closest("tr").rowIndex} cell - ${e.target.closest("td").cellIndex}`);
        }
    },
    task3: {
        taskItem: "",
        render() {
            const renderArea = document.getElementById("Content-area");
            HW_14.clearContentContainer();
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            let taskContainer = document.createElement("div");
            let caption = document.createElement("h4");
            let paragraphsText = [ "Написать функцию часов, которые показывают дату и время.", "Перерисовка не реже раз в секунду.", "Не перерисовывать данные если они не поменялись.", "Не использовать информацию из HTML разметки.", "Не хранить никакую информацию в глобальных переменных", "", "Часики вроде работают правильно, не понял про глобальные переменные", 'Функция которая относится к этой задаче вынесена в отдельный файл "Date.js"' ];
            let paragraphs = [];
            let paragraph;
            let i;
            for (i = 0; i < paragraphsText.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphsText[i];
                paragraphs.push(paragraph);
            }
            taskContainer.classList.add("Task-container");
            caption.classList.add("Task-title");
            caption.innerText = "Задача №3";
            taskContainer.appendChild(caption);
            taskContainer.appendChild(paragraphs[0]);
            taskContainer.appendChild(paragraphs[1]);
            taskContainer.appendChild(paragraphs[2]);
            renderArea.appendChild(taskContainer);
            this.taskItem = taskContainer;
        },
        createClock() {
            let self = this;
            let clocks = document.querySelectorAll("header span.Date-item:not(.Date-item--colon)");
            let currentDate = new Date();
            let hours = currentDate.getHours();
            let minutes = currentDate.getMinutes();
            let seconds = currentDate.getSeconds();
            clocks[0].innerText = self.normalizeTime(hours);
            clocks[1].innerText = self.normalizeTime(minutes);
            clocks[2].innerText = self.normalizeTime(seconds);
            return function() {
                let newDate = new Date();
                if (hours !== newDate.getHours()) {
                    hours = newDate.getHours();
                    clocks[0].innerText = self.normalizeTime(hours);
                }
                if (minutes !== newDate.getMinutes()) {
                    minutes = newDate.getMinutes();
                    clocks[1].innerText = self.normalizeTime(minutes);
                }
                seconds = newDate.getSeconds();
                clocks[2].innerText = self.normalizeTime(seconds);
            };
        },
        createDate() {
            let self = this;
            const date = document.querySelectorAll('[data-date="Date"] span');
            let currentDate = new Date();
            let day = currentDate.getDate();
            let month = currentDate.getMonth();
            let year = currentDate.getFullYear();
            date[0].innerText = self.normalizeTime(day) + ".";
            date[1].innerText = self.normalizeTime(month + 1) + ".";
            date[2].innerText = year;
            return function() {
                let newDate = new Date();
                if (day !== newDate.getDate()) {
                    day = newDate.getDate();
                    date[0].innerText = self.normalizeTime(day) + ".";
                }
                if (month !== newDate.getMonth()) {
                    month = newDate.getMonth();
                    date[1].innerText = self.normalizeTime(month + 1) + ".";
                }
                if (year !== newDate.getFullYear()) {
                    year = newDate.getFullYear();
                    date[1].innerText = year;
                }
            };
        },
        normalizeTime(value) {
            return value < 10 ? "0" + value : "" + value;
        }
    },
    task4: {
        taskItem: "",
        render() {
            HW_14.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            let taskContainer = document.createElement("div");
            let caption = document.createElement("h4");
            let paragraphsText = [ "Написать функцию, которая после изменения окна выводит его размеры.", "Выводить информацию после того как пользователь не менял размер 2 секунды", "Все работает можно пробовать" ];
            let paragraph;
            let i;
            taskContainer.appendChild(caption);
            for (i = 0; i < paragraphsText.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphsText[i];
                taskContainer.appendChild(paragraph);
            }
            taskContainer.classList.add("Task-container");
            caption.classList.add("Task-title");
            caption.innerText = "Задача №4";
            renderArea.appendChild(taskContainer);
            this.taskItem = taskContainer;
        },
        resizeID: "",
        resizeFunction() {
            function getResize() {
                const container = document.querySelector("header .Header-currentSize span");
                container.innerText = `${window.innerWidth} x ${window.innerHeight} px`;
            }
            function renderResize() {
                clearTimeout(HW_14.task4.resizeID);
                HW_14.task4.resizeID = setTimeout(getResize, 2e3);
            }
            getResize();
            window.addEventListener("resize", renderResize);
        }
    },
    clearContentContainer: function() {
        const renderArea = document.getElementById("Content-area");
        while (renderArea.firstChild) {
            renderArea.removeChild(renderArea.firstChild);
        }
    }
};

function renderHW_14(e) {
    const task = e.target.closest("li.Menu-item");
    let taskNumber;
    if (task.classList.contains("disabled") || task.parentElement.classList.contains("Menu")) {
        return;
    }
    taskNumber = parseInt(task.dataset.task);
    switch (taskNumber) {
      case 1:
        HW_14.task1.render();
        break;

      case 2:
        HW_14.task2.render();
        break;

      case 3:
        HW_14.task3.render();
        break;

      case 4:
        HW_14.task4.render();
        break;

      default:
        alert("This task doesn't exist :(");
    }
}

document.addEventListener("DOMContentLoaded", function() {
    let renderClock = HW_14.task3.createClock();
    let renderDate = HW_14.task3.createDate();
    renderClock();
    renderDate();
    setInterval(renderClock, 1e3);
    setInterval(renderDate, 1e3);
});

window.addEventListener("DOMContentLoaded", HW_14.task4.resizeFunction);

"use strict";

const defaultMenuWork16 = document.querySelector('#Menu li.Menu-item[data-work="16"]');

const tabletMenuWork16 = document.querySelector('#Menu--tablet li.Menu-item[data-work="16"]');

defaultMenuWork16.addEventListener("click", renderHW_16);

tabletMenuWork16.addEventListener("click", renderHW_16);

const HW_16 = {
    task1: {
        taskItem: "",
        render: function() {
            HW_16.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            const taskContainer = document.createElement("div");
            const caption = document.createElement("h4");
            const paragraphsText = [ "Create a stopwatch function that counts user time on the site", "When hovering over the stopwatch, time freezes", 'When you press the "ESC" button the stopwatch is reset.', "The stopwatch is located on the bottom left" ];
            let paragraph;
            let i;
            renderArea.appendChild(taskContainer);
            taskContainer.classList.add("Task-container");
            taskContainer.appendChild(caption);
            caption.classList.add("Task-title");
            caption.innerText = "Task #1";
            for (i = 0; i < paragraphsText.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphsText[i];
                taskContainer.appendChild(paragraph);
            }
            this.taskItem = taskContainer;
        }
    },
    task2: {
        taskItem: "",
        render: function() {
            HW_16.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            const taskContainer = document.createElement("div");
            const caption = document.createElement("h4");
            let button;
            let row = document.createElement("div");
            const paragraphs = [ "Create a single function for a container with 3 buttons.", "When you press the button, it changes its color.", "When you press the button again, it is painted in its base color." ];
            let paragraph;
            let mediaContainer;
            let i;
            renderArea.appendChild(taskContainer);
            taskContainer.classList.add("Task-container");
            taskContainer.appendChild(caption);
            caption.classList.add("Task-title");
            caption.innerText = "Task #2";
            for (i = 0; i < paragraphs.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphs[i];
                taskContainer.appendChild(paragraph);
            }
            taskContainer.appendChild(row);
            row.className = "row";
            row.style.margin = "15px 0";
            row.addEventListener("click", this.changeColor);
            for (i = 0; i < 3; i++) {
                mediaContainer = document.createElement("div");
                mediaContainer.className = "cell-4 cell-ml";
                mediaContainer.style.textAlign = "center";
                button = document.createElement("button");
                button.className = "Button";
                button.innerText = `Button #${i + 1}`;
                mediaContainer.appendChild(button);
                row.appendChild(mediaContainer);
            }
            this.taskItem = taskContainer;
        },
        changeColor: function(e) {
            if (e.target.tagName === "BUTTON") {
                if (!e.target.style.background) {
                    e.target.style.background = HW_16.task2.getRandomColor();
                } else {
                    e.target.style.background = "";
                }
            }
        },
        getRandomColor: function() {
            return `rgb(${Math.random() * 256},${Math.random() * 256},${Math.random() * 256}`;
        }
    },
    clearContentContainer: function() {
        const renderArea = document.getElementById("Content-area");
        while (renderArea.firstChild) {
            renderArea.removeChild(renderArea.firstChild);
        }
    }
};

function renderHW_16(e) {
    const task = e.target.closest("li.Menu-item");
    let taskNumber;
    if (task.classList.contains("disabled") || task.parentElement.classList.contains("Menu")) {
        return;
    }
    taskNumber = parseInt(task.dataset.task);
    switch (taskNumber) {
      case 1:
        HW_16.task1.render();
        break;

      case 2:
        HW_16.task2.render();
        break;

      case 3:
        HW_16.task3.render();
        break;

      case 4:
        HW_16.task4.render();
        break;

      default:
        alert("This task doesn't exist :(");
    }
}

const renderStopwatch = createStopwatch();

let stopwatchID;

function createStopwatch() {
    let clocks = document.querySelectorAll('.Date[data-date ="Stopwatch"] .Date-item');
    let seconds = 0;
    let minutes = 0;
    let hours = 0;
    clocks[2].innerText = normalizeTime(seconds);
    clocks[1].innerText = normalizeTime(minutes);
    clocks[0].innerText = normalizeTime(hours);
    window.addEventListener("keyup", resetStopwatch);
    function resetStopwatch(e) {
        if (e.keyCode === 27) {
            clearInterval(stopwatchID);
            seconds = minutes = hours = 0;
            clocks[2].innerText = normalizeTime(seconds);
            clocks[1].innerText = normalizeTime(minutes);
            clocks[0].innerText = normalizeTime(hours);
            setInterval(renderStopwatch, 999);
        }
    }
    return function() {
        seconds++;
        if (seconds === 60) {
            seconds = 0;
            minutes++;
            clocks[1].innerText = normalizeTime(minutes);
            if (minutes === 60) {
                minutes = 0;
                hours++;
                clocks[0].innerText = normalizeTime(hours);
            }
        }
        clocks[2].innerText = normalizeTime(seconds);
    };
}

function runStopwatch() {
    stopwatchID = setInterval(renderStopwatch, 999);
}

function normalizeTime(value) {
    return value < 10 ? "0" + value : "" + value;
}

document.addEventListener("DOMContentLoaded", function() {
    runStopwatch();
});

document.querySelector('.Date[data-date ="Stopwatch"]').addEventListener("mouseenter", function() {
    clearInterval(stopwatchID);
});

document.querySelector('.Date[data-date ="Stopwatch"]').addEventListener("mouseleave", function() {
    runStopwatch(renderStopwatch);
});

"use strict";

const defaultMenuWork18 = document.querySelector('#Menu li.Menu-item[data-work="18"]');

const tabletMenuWork18 = document.querySelector('#Menu--tablet li.Menu-item[data-work="18"]');

defaultMenuWork18.addEventListener("click", renderHW_18);

tabletMenuWork18.addEventListener("click", renderHW_18);

class Carousel {
    constructor({name: name, container: container, imagesPath: imagesPath, startPosition: startPosition = 1, pauseOnHover: pauseOnHover = false, autoPlaySpeed: autoPlaySpeed = 2500, loop: loop = true, speed: speed}) {
        if (!name || !imagesPath || !container) {
            throw new Error("Input error: required parameters not passed");
        }
        if (startPosition > imagesPath.length) {
            throw new Error("Input error: start position can't be greater then slides quantity");
        }
        this._name = name;
        this._renderContainer = container;
        this._imagesPath = imagesPath;
        this._autoPlaySpeed = autoPlaySpeed;
        this._pauseState = pauseOnHover;
        this._loop = loop;
        this._slideChangeSpeed = speed;
        this.constructor.createDefaultSlider.call(this);
        this.constructor.setCarouselShift.call(this, startPosition);
        this.constructor.runCarousel.call(this);
    }
    static createDefaultSlider() {
        const carousel = document.createElement("div");
        const carouselFrame = document.createElement("div");
        const slidesStrip = document.createElement("div");
        let currentSlideIndicator = document.createElement("h4");
        let slide;
        let slideImage;
        let i;
        this._frame = carouselFrame;
        this._strip = slidesStrip;
        this._indicator = currentSlideIndicator;
        this._slides = [];
        this._renderContainer.appendChild(carousel);
        carousel.dataset.carousel = this._name + "";
        carousel.className = "Carousel";
        carouselFrame.className = "Carousel-frame";
        slidesStrip.className = "Carousel-strip";
        currentSlideIndicator.className = "Carousel-slideIndicator";
        carousel.appendChild(carouselFrame);
        carouselFrame.appendChild(currentSlideIndicator);
        carouselFrame.appendChild(slidesStrip);
        this._frameWidth = carouselFrame.clientWidth;
        if (this._loop) {
            for (i = Math.ceil(this._imagesPath.length / 2); i < this._imagesPath.length; i++) {
                slide = document.createElement("div");
                slideImage = document.createElement("img");
                slide.className = "Carousel-item cloned";
                slideImage.className = "Carousel-itemImage";
                slideImage.setAttribute("alt", "Cat image");
                slideImage.src = this._imagesPath[i];
                slide.appendChild(slideImage);
                slidesStrip.appendChild(slide);
                slide.slideNumber = i + 1;
                this._slides.push(slide);
            }
            for (i = 0; i < this._imagesPath.length; i++) {
                slide = document.createElement("div");
                slideImage = document.createElement("img");
                slide.className = "Carousel-item";
                slideImage.className = "Carousel-itemImage";
                slideImage.setAttribute("alt", "Cat image");
                slideImage.src = this._imagesPath[i];
                slide.appendChild(slideImage);
                slidesStrip.appendChild(slide);
                slide.slideNumber = i + 1;
                this._slides.push(slide);
            }
            for (i = 0; i < Math.floor(this._imagesPath.length / 2); i++) {
                slide = document.createElement("div");
                slideImage = document.createElement("img");
                slide.className = "Carousel-item cloned";
                slideImage.className = "Carousel-itemImage";
                slideImage.setAttribute("alt", "Cat image");
                slideImage.src = this._imagesPath[i];
                slide.appendChild(slideImage);
                slidesStrip.appendChild(slide);
                slide.slideNumber = i + 1;
                this._slides.push(slide);
            }
        }
        this._stripWidth = this._frameWidth * this._slides.length;
        slidesStrip.style.width = this._stripWidth + "px";
        if (this._pauseState) {
            this.constructor.createPauseState.call(this, carouselFrame);
        }
    }
    static setCarouselShift(index) {
        const shiftValue = (Math.ceil(this._imagesPath.length / 2) + (index - 1)) * this._frameWidth;
        this._strip.style.transform = `translateX(-${shiftValue})`;
        this._currentTranslate = shiftValue;
        this._indicator.innerText = `Slide #${index}`;
    }
    static runCarousel() {
        const self = this;
        const clonesQuantity = Math.floor(this._slides.length / 2);
        let currentAnimationProgress = 0;
        let animationTranslate = 0;
        this._currentSlideIndex = this._currentTranslate / this._frameWidth;
        this._firstSlideTranslate = clonesQuantity / 2 * this._frameWidth;
        this._lastSlideTranslate = this._frameWidth * (this._slides.length - 1 - clonesQuantity / 2);
        this._slides[this._currentSlideIndex].classList.add("active");
        function scrollSlide(percentOfAnimation) {
            currentAnimationProgress = percentOfAnimation;
            animationTranslate = percentOfAnimation * self._frameWidth;
            self._currentTranslate = animationTranslate + self._currentSlideIndex * self._frameWidth;
            self._strip.style.transform = `translateX(-${self._currentTranslate}px)`;
            if (self._currentTranslate > self._lastSlideTranslate) {
                self._currentTranslate = self._firstSlideTranslate - self._frameWidth + self._currentTranslate - self._lastSlideTranslate;
                self._strip.style.transform = `translateX(-${self._currentTranslate}px)`;
            }
            if (percentOfAnimation === 1) {
                self._slides[self._currentSlideIndex].classList.remove("active");
                animationTranslate = 0;
                self._currentSlideIndex = self._currentTranslate / self._frameWidth;
                self._currentSlideNumber = self._slides[self._currentSlideIndex].slideNumber;
                self._indicator.innerText = `Slide #${self._currentSlideNumber}`;
                self._slides[self._currentSlideIndex].classList.add("active");
            }
        }
        function runCarousel() {
            this._sliderIntervalID = setInterval(this.constructor.startAnimation, this._autoPlaySpeed, scrollSlide, this._slideChangeSpeed);
        }
        runCarousel.call(this);
        const makeCarouselResponsvie = new ResizeSensor(this._frame, adjustCarousel);
        function adjustCarousel() {
            const slideWidth = self._frameWidth = self._frame.clientWidth;
            self._stripWidth = slideWidth * self._slides.length;
            self._currentTranslate = animationTranslate + self._currentSlideIndex * self._frameWidth;
            self._firstSlideTranslate = clonesQuantity / 2 * self._frameWidth;
            self._lastSlideTranslate = slideWidth * (self._slides.length - clonesQuantity / 2 - 1);
            self._strip.style.width = self._stripWidth + "px";
            self._strip.style.transform = `translateX(-${self._currentTranslate}px`;
        }
    }
    static startAnimation(animationFunction, animationDuration) {
        let animationTimeStart = performance.now();
        requestAnimationFrame(function animate(timePassed) {
            let animationPercentage = (timePassed - animationTimeStart) / animationDuration;
            if (animationPercentage > 1) {
                animationPercentage = 1;
            }
            animationFunction(animationPercentage);
            if (animationPercentage < 1) {
                requestAnimationFrame(animate);
            }
        });
    }
    static createPauseState(container) {
        const freezeWrapper = document.createElement("div");
        const freezeCaption = document.createElement("span");
        const freezeSubCaption = document.createElement("span");
        freezeWrapper.className = "Carousel-frozen";
        freezeCaption.className = "Carousel-frozenCaption";
        freezeSubCaption.className = "Carousel-frozenText";
        freezeCaption.innerText = "The Carousel is frozen.";
        freezeSubCaption.innerText = "Rather, remove the mouse, the kittens are cold :(";
        freezeWrapper.appendChild(freezeCaption);
        freezeWrapper.appendChild(freezeSubCaption);
        this._pauseBlock = freezeWrapper;
        container.appendChild(freezeWrapper);
        container.addEventListener("mouseenter", this.constructor.showPauseState.bind(this));
        container.addEventListener("mouseleave", this.constructor.hidePauseState.bind(this));
    }
    static showPauseState() {
        this._pauseBlock.classList.add("visible");
    }
    static hidePauseState() {
        this._pauseBlock.classList.remove("visible");
    }
}

const HW_18 = {
    task1: {
        taskItem: "",
        sliderImages: [ "images/slide1.jpg", "images/slide2.jpg", "images/slide3.jpg", "images/slide4.jpg" ],
        sliderIntervalID: 0,
        render() {
            HW_18.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            const taskContainer = document.createElement("div");
            const caption = document.createElement("h4");
            const paragraphsText = [ "Create infinite carousel", "This is not the simple carousel, it`s RESPONSIVE, you can ", "You can test it using the icon in the bottom right", "The slide that is shown gets class active", "During the creation of the carousel, clones are created will be used in the future" ];
            let paragraph;
            let i;
            renderArea.appendChild(taskContainer);
            taskContainer.classList.add("Task-container");
            taskContainer.appendChild(caption);
            caption.classList.add("Task-title");
            caption.innerText = "Task #1";
            for (i = 0; i < paragraphsText.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphsText[i];
                taskContainer.appendChild(paragraph);
            }
            const carousel = new Carousel({
                name: "Cat carousel",
                container: taskContainer,
                imagesPath: this.sliderImages,
                pauseOnHover: false,
                loop: true,
                startPosition: 1,
                autoPlaySpeed: 3e3,
                speed: 500
            });
            this.taskItem = taskContainer;
        },
        renderCarousel() {
            const slider = document.createElement("div");
            const sliderViewWindow = document.createElement("div");
            const sliderStrip = document.createElement("div");
            const freezeWrapper = document.createElement("div");
            const freezeCaption = document.createElement("span");
            const freezeSubCaption = document.createElement("span");
            let slideCaption = document.createElement("h4");
            let slide;
            let slideImage;
            let i;
            this.taskItem.appendChild(slider);
            this.sliderWindow = sliderViewWindow;
            slideCaption.className = "Carousel-slideIndicator";
            slideCaption.innerText = "Slide #1";
            sliderViewWindow.appendChild(slideCaption);
            slider.className = "Carousel";
            sliderViewWindow.appendChild(freezeWrapper);
            freezeWrapper.className = "Carousel-frozen";
            freezeCaption.innerText = "The slider is frozen.";
            freezeSubCaption.innerText = "Rather, remove the mouse, the kittens are cold :(";
            freezeCaption.className = "Carousel-frozenCaption";
            freezeSubCaption.className = "Carousel-frozenText";
            freezeWrapper.appendChild(freezeCaption);
            freezeWrapper.appendChild(freezeSubCaption);
            sliderViewWindow.className = "Carousel-frame";
            sliderStrip.className = "Carousel-strip";
            slider.appendChild(sliderViewWindow);
            sliderStrip.style.width = sliderViewWindow.clientWidth * (this.sliderImages.length + 1) + "px";
            sliderViewWindow.appendChild(sliderStrip);
            for (i = 0; i <= this.sliderImages.length; i++) {
                slide = document.createElement("div");
                slide.className = "Carousel-item";
                slideImage = document.createElement("img");
                slideImage.className = "Carousel-itemImage";
                slideImage.draggable = false;
                slideImage.src = i === this.sliderImages.length ? this.sliderImages[0] : this.sliderImages[i];
                slideImage.setAttribute("alt", "Slider image");
                slide.appendChild(slideImage);
                sliderStrip.appendChild(slide);
            }
        },
        runCarousel() {
            const self = this;
            const carousel = document.querySelector(".Carousel");
            const sliderStrip = document.querySelector(".Carousel-strip");
            const slides = document.querySelectorAll(".Carousel-item");
            const currentSliderCaption = document.querySelector(".Carousel-slideIndicator");
            let translateX;
            let currentSlideNumber = 0;
            let currentAnimationProgress;
            function scrollSlide(percentOfAnimation) {
                currentAnimationProgress = percentOfAnimation;
                translateX = (percentOfAnimation + currentSlideNumber) * self.sliderWindow.clientWidth;
                sliderStrip.style.transform = `translateX(-${translateX}px)`;
                if (percentOfAnimation === 1) {
                    currentSlideNumber++;
                }
                if (currentSlideNumber >= slides.length - 1) {
                    currentSlideNumber = 0;
                    translateX = 0;
                }
                currentSliderCaption.innerText = `Slider #${currentSlideNumber + 1}`;
            }
            function runCarousel() {
                self.sliderIntervalID = setInterval(self.toNextSlide, 3e3, scrollSlide, 500);
            }
            runCarousel();
            new ResizeSensor(self.sliderWindow, adjustSlider);
            function adjustSlider() {
                sliderStrip.style.width = self.sliderWindow.clientWidth * (self.sliderImages.length + 1) + "px";
                sliderStrip.style.transform = `translateX(-${currentAnimationProgress * currentSlideNumber * self.sliderWindow.clientWidth}px`;
            }
        },
        toNextSlide(animationFunction, animationDuration) {
            let animationTimeStart = performance.now();
            requestAnimationFrame(function animate(timePassed) {
                let animationPercentage = (timePassed - animationTimeStart) / animationDuration;
                if (animationPercentage > 1) {
                    animationPercentage = 1;
                }
                animationFunction(animationPercentage);
                if (animationPercentage < 1) {
                    requestAnimationFrame(animate);
                }
            });
        },
        freezeSlider() {
            clearInterval(HW_18.task1.sliderIntervalID);
        }
    },
    task2: {
        taskItem: "",
        render() {
            const self = this;
            HW_18.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            const taskContainer = document.createElement("div");
            const caption = document.createElement("h4");
            const table = document.createElement("table");
            const tableWrapper = document.createElement("div");
            let tbody = document.createElement("tbody");
            tableWrapper.className = "Task-tableWrapper";
            tableWrapper.appendChild(table);
            table.appendChild(this.getTableHead());
            table.appendChild(tbody);
            this.studentsBase.members.forEach(function(student) {
                tbody.appendChild(self.getStudentRow(student));
            });
            const paragraphs = [ "Create a students base table layout" ];
            let paragraph;
            let i;
            renderArea.appendChild(taskContainer);
            taskContainer.classList.add("Task-container");
            taskContainer.appendChild(caption);
            caption.classList.add("Task-title");
            caption.innerText = "Task #2";
            for (i = 0; i < paragraphs.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphs[i];
                taskContainer.appendChild(paragraph);
            }
            table.appendChild(tbody);
            taskContainer.appendChild(tableWrapper);
            this.taskItem = taskContainer;
        },
        getStudentRow({id: id = "?", age: age = "?", specialization: specialization = "?", firstName: firstName = "?", lastName: lastName = "?", start: start = "?", finish: finish = "?"}) {
            const tr = document.createElement("tr");
            const student = arguments[0];
            let checkbox;
            let deleteControl;
            let editControl;
            let td;
            let key;
            td = document.createElement("td");
            checkbox = document.createElement("input");
            checkbox.setAttribute("type", "checkbox");
            checkbox.setAttribute("title", "Выделить");
            td.appendChild(checkbox);
            tr.appendChild(td);
            for (key in student) {
                td = document.createElement("td");
                td.innerText = student[key];
                tr.appendChild(td);
            }
            td = document.createElement("td");
            editControl = getEditIcon();
            td.appendChild(editControl);
            tr.appendChild(td);
            editControl.addEventListener("click", editRow);
            td = document.createElement("td");
            deleteControl = getDeleteIcon();
            td.appendChild(deleteControl);
            tr.appendChild(td);
            deleteControl.addEventListener("click", deleteRow);
            return tr;
            function getDeleteIcon() {
                let div = document.createElement("div");
                div.innerHTML = '<svg class="Task-tableIcon" height="20px" viewBox="-40 0 427 427.00131" width="20px" ' + 'xmlns="http://www.w3.org/2000/svg">' + '<path d="m308.601562 62.300781c15.464844 0 28 12.535157 28 28 0 15.464844-12.535156 28-28 28h-270.402343c-' + '15.460938 0-28-12.535156-28-28 0-15.464843 12.539062-28 28-28zm0 0" fill="#00acea"/>' + '<path d="m308 118.703125v254.796875c0 25.089844-17.910156 43-40 43h-189.199219c-22.089843 0-40-17.' + '910156-40-43v-255.199219h269.199219zm0 0" fill="#00efd1"/><g fill="#083863"><path d="m232.402344 154.703125c' + "-5.523438 0-10 4.476563-10 10v189c0 5.519531 4.476562 10 10 10 5.519531 0 10-4.480469 10-10v-189c0-5.523" + '437-4.480469-10-10-10zm0 0"/><path d="m114.402344 154.703125c-5.523438 0-10 4.476563-10 10v189c0 5.519' + '531 4.476562 10 10 10 5.519531 0 10-4.480469 10-10v-189c0-5.523437-4.480469-10-10-10zm0 0"/>' + '<path d="m28.402344 127.121094v246.378906c0 14.5625 5.335937 28.234375 14.667968 38.050781 9.28125 ' + "9.839844 22.203126 15.425781 35.730469 15.449219h189.199219c13.527344-.023438 26.449219-5.609375 35.7" + "30469-15.449219 9.332031-9.816406 14.671875-23.488281 14.671875-38.050781v-246.367188c6.503906-1.816406" + " 12.445312-5.246093 17.277344-9.96875 10.8125-10.964843 14-27.347656 8.089843-41.570312-5.910156-14.22" + "2656-19.765625-23.519531-35.167969-23.59375h-51.199218v-12.5c.058594-10.511719-4.097656-20.605469-11.542969" + "-28.03125-7.441406-7.421875-17.546875-11.5546875-28.058594-11.46875h-88.800781c-10.511719-.0859375-20.617" + "188 4.046875-28.058594 11.46875-7.445312 7.425781-11.601562 17.519531-11.539062 28.03125v12.5h-51.203125" + "c-21.015625.21875-37.996094 17.210938-38.199219 38.226562.101562 17.285157 11.71875 32.378907 28.402344 3" + "6.894532zm239.597656 279.878906h-189.199219c-17.101562 0-30.398437-14.6875-30.398437-33.5v-245.5h250v245." + "5c0 18.8125-13.300782 33.5-30.402344 33.5zm-158.597656-367.5c-.066406-5.207031 1.980468-10.21875 5.671875" + "-13.894531 3.695312-3.675781 8.71875-5.695313 13.925781-5.605469h88.800781c5.207031-.089844 10.230469 1.92" + "9688 13.925781 5.605469 3.691407 3.671875 5.738282 8.6875 5.675782 13.894531v12.5h-128zm-83.9375 37.929688c" + "3.355468-3.429688 7.9375-5.382813 12.734375-5.429688h270.402343c9.964844.082031 18 8.1875 18 18.152344-." + "003906 4.757812-1.90625 9.316406-5.285156 12.667968-3.382812 3.351563-7.957031 5.214844-12.714844 5.17968" + "8h-270.402343c-9.921875.023438-17.980469-8.003906-18-17.921875-.007813-4.753906 1.886719-9.308594 5.26562" + '5-12.648437zm0 0"/><path d="m173.402344 154.703125c-5.523438 0-10 4.476563-10 10v189c0 5.519531 4.476562' + ' 10 10 10 5.519531 0 10-4.480469 10-10v-189c0-5.523437-4.480469-10-10-10zm0 0"/></g></svg>';
                return div.firstChild;
            }
            function getEditIcon() {
                let div = document.createElement("div");
                div.innerHTML = '<svg version="1.1" class="Task-tableIcon" width="20px" height="20px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n' + '\t viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve">\n' + '<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="26.5698" y1="258" x2="485.4302" y2="258" gradientTransform="matrix(1 0 0 -1 0 514)">\n' + '<stop  offset="0" style="stop-color:#00DDE6"/>\n' + '\t<stop  offset="0.021" style="stop-color:#03D7E6"/>\n' + '\t<stop  offset="0.293" style="stop-color:#25B9E6"/>\n' + '\t<stop  offset="0.554" style="stop-color:#36B0E6"/>\n' + '\t<stop  offset="0.796" style="stop-color:#4A98E6"/>\n' + '\t<stop  offset="1" style="stop-color:#4B96E4"/>' + "</linearGradient>\n" + '<path style="fill:url(#SVGID_1_);" d="M193.459,492c0,11.046-8.954,20-20,20H106.57c-44.112,0-80-35.888-80-80V80\n' + "\tc0-44.112,35.888-80,80-80h245.889c44.112,0,80,35.888,80,80v123c0,11.046-8.954,20-20,20s-20-8.954-20-20V80\n" + "\tc0-22.056-17.944-40-40-40H106.57c-22.056,0-40,17.944-40,40v352c0,22.056,17.944,40,40,40h66.889\n" + "\tC184.505,472,193.459,480.954,193.459,492z M332.459,120h-206c-11.046,0-20,8.954-20,20s8.954,20,20,20h206c11.046,0,20-8.954,20-20\n" + "\tS343.505,120,332.459,120z M352.459,220c0-11.046-8.954-20-20-20h-206c-11.046,0-20,8.954-20,20s8.954,20,20,20h206\n" + "\tC343.505,240,352.459,231.046,352.459,220z M126.459,280c-11.046,0-20,8.954-20,20s8.954,20,20,20H251.57c11.046,0,20-8.954,20-20\n" + "\ts-8.954-20-20-20H126.459z M467.885,374.426L358.312,483.793c-2.44,2.436-5.468,4.199-8.79,5.119l-80.725,22.361\n" + "\tc-1.763,0.489-3.559,0.727-5.338,0.727c-5.317,0-10.501-2.123-14.317-6.034c-5.094-5.221-6.941-12.8-4.821-19.78l23.913-78.725\n" + "\tc0.958-3.152,2.678-6.018,5.01-8.345l109.803-109.56c23.379-23.379,61.443-23.378,84.837,0.016\n" + "\tC491.279,312.968,491.279,351.032,467.885,374.426z M407.428,378.254l-28.29-28.29l-74.089,73.925l-11.885,39.129l40.612-11.25\n" + "\tL407.428,378.254z M439.601,317.858c-7.798-7.798-20.486-7.798-28.284,0l-3.862,3.854l28.285,28.285l3.875-3.867\n" + '\tC447.399,338.344,447.399,325.656,439.601,317.858z"/>\n' + "</svg>";
                return div.firstChild;
            }
            function deleteRow() {
                this.closest("tr").parentElement.removeChild(this.closest("tr"));
            }
            function editRow() {
                const data = this.closest("tr").children;
                this.classList.toggle("editing");
                if (this.classList.contains("editing")) {
                    [].forEach.call(data, function(el) {
                        if (el.innerText) {
                            el.innerHTML = `<input type="text" size="1" value="${el.innerText}"/>`;
                        }
                    });
                } else {
                    [].forEach.call(data, function(el) {
                        if (el.firstChild.tagName === "INPUT" && el.firstChild.type === "text") {
                            el.innerHTML = el.firstChild.value;
                        }
                    });
                }
            }
        },
        getTableHead() {
            const thead = document.createElement("thead");
            const tr = document.createElement("tr");
            let th;
            this.tableParam.forEach(function(param) {
                th = document.createElement("th");
                th.innerText = getParamTitle(param);
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            return thead;
            function getParamTitle(param) {
                let title;
                switch (param) {
                  case "pick":
                    title = "Pick student";
                    break;

                  case "id":
                    title = "ID";
                    break;

                  case "age":
                    title = "Age";
                    break;

                  case "specialization":
                    title = "Specialization";
                    break;

                  case "firstName":
                    title = "First Name";
                    break;

                  case "lastName":
                    title = "Last Name";
                    break;

                  case "start":
                    title = "Year of enrollment";
                    break;

                  case "finish":
                    title = "Year of graduation";
                    break;

                  case "delete":
                    title = "Delete student";
                    break;

                  case "edit":
                    title = "Edit student";
                    break;

                  default:
                    title = "unknown parameter";
                }
                return title;
            }
        },
        tableParam: [ "pick", "id", "specialization", "firstName", "lastName", "age", "start", "finish", "edit", "delete" ],
        studentsBase: {
            name: "Students Base",
            members: [ {
                id: 1,
                specialization: "Философия",
                firstName: "Егор",
                lastName: "Гринько",
                age: 18,
                start: "2018",
                finish: "2022"
            }, {
                id: 2,
                specialization: "Экономика",
                firstName: "Никита",
                lastName: "Булькач",
                age: 19,
                start: "2014",
                finish: "2018"
            }, {
                id: 3,
                specialization: "Политология",
                firstName: "Алина",
                lastName: "Брюславец",
                age: 20,
                start: "2015",
                finish: "2019"
            }, {
                id: 4,
                specialization: "Менеджмент",
                firstName: "Марина",
                lastName: "Заец",
                age: 17,
                start: "2016",
                finish: "2020"
            }, {
                id: 5,
                specialization: "Кибербезапасность",
                firstName: "Сергей",
                lastName: "Мазница",
                age: 18,
                start: "2007",
                finish: "2011"
            }, {
                id: 6,
                specialization: "Туризм",
                firstName: "Богдан",
                lastName: "Потемкин",
                age: 21,
                start: "2009",
                finish: "2013"
            }, {
                id: 7,
                specialization: "Прикладная механика",
                firstName: "Александр",
                lastName: "Шевченко",
                age: 19,
                start: "2014",
                finish: "2018"
            }, {
                id: 8,
                specialization: "Химическия технологии",
                firstName: "Евгений",
                lastName: "Анкудинов",
                age: 22,
                start: "2003",
                finish: "2017"
            }, {
                id: 9,
                specialization: "Транспортныые технологии",
                firstName: "Виталий",
                lastName: "Кузьменко",
                age: 19,
                start: "2008",
                finish: "2012"
            }, {
                id: 10,
                specialization: "Правоведение",
                firstName: "Дарина",
                lastName: "Серяпова",
                age: 20,
                start: "2012",
                finish: "2016"
            }, {
                id: 11,
                specialization: "Стоматология",
                firstName: "Эльвин",
                lastName: "Гуйсейнов",
                age: 22,
                start: "2009",
                finish: "2013"
            }, {
                id: 12,
                specialization: "Маркетинг",
                firstName: "Александр",
                lastName: "Степанов",
                age: 18,
                start: "2017",
                finish: "2021"
            } ]
        }
    },
    clearContentContainer: function() {
        const renderArea = document.getElementById("Content-area");
        while (renderArea.firstChild) {
            renderArea.removeChild(renderArea.firstChild);
        }
    }
};

function renderHW_18(e) {
    const task = e.target.closest("li.Menu-item");
    let taskNumber;
    if (task.classList.contains("disabled") || task.parentElement.classList.contains("Menu")) {
        return;
    }
    taskNumber = parseInt(task.dataset.task);
    switch (taskNumber) {
      case 1:
        HW_18.task1.render();
        break;

      case 2:
        HW_18.task2.render();
        break;

      case 3:
        HW_18.task3.render();
        break;

      case 4:
        HW_18.task4.render();
        break;

      default:
        alert("This task doesn't exist :(");
    }
}

"use strict";

const defaultMenuWork20 = document.querySelector('#Menu li.Menu-item[data-work="20"]');

const tabletMenuWork20 = document.querySelector('#Menu--tablet li.Menu-item[data-work="20"]');

defaultMenuWork20.addEventListener("click", renderHW_20);

tabletMenuWork20.addEventListener("click", renderHW_20);

const HW_20 = {
    task1: {
        taskItem: "",
        images: [ "images/Cats-cards/Card-image1.jpg", "images/Cats-cards/Card-image2.jpg", "images/Cats-cards/Card-image3.jpg" ],
        titles: [ "Character", "Genesis", "Look" ],
        descriptions: [ "Persian cats can not live outside the house. In general, cats of this breed are rather capricious and stubborn. At the same time, they are quite balanced. They are not prone to active aggression, and although they can stand up for themselves, they often simply avoid contact with those who they don’t like.", "Now there are about 100 varieties of these cats in color. There is a black, white, gray, blue, red, cream, red, purple cat. Eye color is dark orange, blue, copper, green. Cats of a certain color have their own eye color. Cats of the same color should not have spots and shades.", "A distinctive feature of the breed is a small, wide and snub nose. The type of cats with a very small, upturned nose is called “extreme”, and a relatively long and slightly upturned nose is called “classic”. Short and muscular paws are also distinguished. Extreme type is divorced mainly in the United States, and the classic in Europe. The weight of an adult cat can reach 7 kilograms." ],
        cardQuantity: 3,
        isPromiseChainActive: false,
        render() {
            HW_20.clearContentContainer();
            const renderArea = document.getElementById("Content-area");
            let task;
            if (this.taskItem) {
                renderArea.appendChild(this.taskItem);
                return;
            }
            const taskContainer = document.createElement("div");
            const caption = document.createElement("h4");
            const paragraphsText = [ "Nothing to tell, just click the button and it will work" ];
            let promiseAsyncButton;
            let promiseSyncButton;
            let paragraph;
            let i;
            renderArea.appendChild(taskContainer);
            taskContainer.appendChild(caption);
            caption.className = "Task-title";
            taskContainer.className = "Task-container";
            caption.innerText = "Promises";
            for (i = 0; i < paragraphsText.length; i++) {
                paragraph = document.createElement("p");
                paragraph.className = "Task-text";
                paragraph.innerText = paragraphsText[i];
                taskContainer.appendChild(paragraph);
            }
            task = this.renderTaskContent();
            taskContainer.appendChild(task);
            promiseAsyncButton = document.querySelector('[data-control="promise-async"');
            promiseSyncButton = document.querySelector('[data-control="promise-sync"');
            promiseAsyncButton.addEventListener("click", this.startAsyncPromise.bind(this));
            promiseSyncButton.addEventListener("click", this.startSyncPromise.bind(this));
            this.taskItem = taskContainer;
        },
        renderTaskContent() {
            const task = document.createElement("div");
            let button;
            let buttonTypes = [ "promise-sync", "promise-async" ];
            let row = document.createElement("div");
            let mediaContainer;
            let i;
            task.className = "cell-12";
            row.className = "Task-container row";
            task.appendChild(row);
            for (i = 0; i < 2; i++) {
                mediaContainer = document.createElement("div");
                button = document.createElement("button");
                mediaContainer.className = "cell-6";
                button.className = "Button Button--centered";
                button.dataset.control = buttonTypes[i];
                button.innerText = buttonTypes[i];
                row.appendChild(mediaContainer);
                mediaContainer.appendChild(button);
            }
            this.renderProgressBar(task);
            this.renderCardList(task);
            return task;
        },
        renderProgressBar(container) {
            const wrapper = document.createElement("div");
            const progressBar = document.createElement("div");
            const bar = document.createElement("div");
            wrapper.className = "Task-container cell-12";
            progressBar.className = "ProgressBar";
            progressBar.dataset.progressBar = "promises";
            bar.className = "ProgressBar-bar";
            container.appendChild(wrapper);
            wrapper.appendChild(progressBar);
            progressBar.appendChild(bar);
        },
        renderCardList(container) {
            const cardList = document.createElement("div");
            let card;
            let i;
            cardList.className = "List-cards";
            for (i = 0; i < this.cardQuantity; i++) {
                card = this.createCard(this.images[i], this.titles[i], this.descriptions[i]);
                cardList.appendChild(card);
            }
            container.appendChild(cardList);
        },
        createCard(image = "images/No-image-available.jpg", title = "", description = "Here must be description, but something gone wrong") {
            let card = document.createElement("div");
            let cardImage = document.createElement("img");
            let cardBox = document.createElement("div");
            let cardTitle = document.createElement("h3");
            let cardText = document.createElement("p");
            card.className = "Card";
            cardTitle.className = "Card-title";
            cardImage.className = "Card-image";
            cardText.className = "Card-description";
            cardBox.className = "Card-box";
            cardTitle.innerText = title;
            cardImage.src = image;
            cardImage.alt = "Cat image";
            cardText.innerText = description;
            card.appendChild(cardImage);
            card.appendChild(cardBox);
            cardBox.appendChild(cardTitle);
            cardBox.appendChild(cardText);
            return card;
        },
        toggleProgressBar() {
            const progressBar = document.querySelector("[data-progress-bar=promises");
            progressBar.classList.toggle("empty");
        },
        startAsyncPromise() {
            if (!this.isPromiseChainActive) {
                const progressBar = document.querySelector("[data-progress-bar=promises");
                progressBar.addEventListener("transitionend", this.runAsyncPromiseChain.bind(this), {
                    once: true
                });
                this.toggleProgressBar();
                this.isPromiseChainActive = true;
            }
        },
        startSyncPromise() {
            if (!this.isPromiseChainActive) {
                const progressBar = document.querySelector("[data-progress-bar=promises");
                progressBar.addEventListener("transitionend", this.runSyncPromiseChain.bind(this), {
                    once: true
                });
                this.toggleProgressBar();
                this.isPromiseChainActive = true;
            }
        },
        runAsyncPromiseChain() {
            const cards = document.querySelectorAll(".List-cards .Card");
            const cardList = document.querySelector(".List-cards");
            const progressBar = document.querySelector("[data-progress-bar=promises");
            const newProgressBar = progressBar.cloneNode(true);
            const cardsChain = new Promise(resolve => {
                [].forEach.call(cards, this.hideCard.bind(this));
                cardList.addEventListener("transitionend", resolve, {
                    once: true
                });
            });
            const resetTask = cardsChain.then(() => {
                progressBar.parentElement.replaceChild(newProgressBar, progressBar);
                return new Promise(resolve => {
                    setTimeout(() => {
                        this.toggleProgressBar();
                        newProgressBar.addEventListener("transitionend", resolve, {
                            once: true
                        });
                    }, 0);
                });
            }).then(() => {
                this.showCards();
            });
        },
        runSyncPromiseChain() {
            const cards = document.querySelectorAll(".List-cards .Card");
            const cardList = document.querySelector(".List-cards");
            const progressBar = document.querySelector("[data-progress-bar=promises");
            const newProgressBar = progressBar.cloneNode(true);
            const self = this;
            let i;
            (async function() {
                for (i = 0; i < cards.length; i++) {
                    await self.hideCard(cards[i]);
                }
                return Promise.resolve();
            })().then(() => {
                progressBar.parentElement.replaceChild(newProgressBar, progressBar);
                return new Promise(resolve => {
                    setTimeout(() => {
                        this.toggleProgressBar();
                        newProgressBar.addEventListener("transitionend", resolve, {
                            once: true
                        });
                    }, 0);
                });
            }).then(() => {
                this.showCards();
                this.isPromiseChainActive = false;
            });
        },
        async hideCard(card) {
            const cardElements = card.children;
            let isPromiseChainEnd = false;
            const hideCardImage = new Promise(resolve => {
                let currentItem = 0;
                cardElements[currentItem].classList.toggle("hidden");
                cardElements[currentItem].addEventListener("transitionend", e => {
                    e.stopPropagation();
                    resolve(currentItem);
                }, {
                    once: true
                });
            });
            const hideCardText = hideCardImage.then(result => {
                result++;
                cardElements[result].classList.toggle("hidden");
                return new Promise(resolve => {
                    cardElements[result].addEventListener("transitionend", e => {
                        e.stopPropagation();
                        resolve();
                    }, {
                        once: true
                    });
                });
            });
            const hideCard = await hideCardText.then(() => {
                card.classList.toggle("hidden");
                return new Promise(resolve => {
                    card.addEventListener("transitionend", () => {
                        isPromiseChainEnd = true;
                        resolve();
                    });
                }, {
                    once: true
                });
            });
            return Promise.resolve();
        },
        showCards() {
            const cards = document.querySelectorAll(".List-cards .Card");
            [].forEach.call(cards, card => {
                card.classList.remove("hidden");
                [].forEach.call(card.children, cardChildElement => cardChildElement.classList.remove("hidden"));
            });
            this.isPromiseChainActive = false;
        }
    },
    clearContentContainer: function() {
        const renderArea = document.getElementById("Content-area");
        while (renderArea.firstChild) {
            renderArea.removeChild(renderArea.firstChild);
        }
    }
};

function renderHW_20(e) {
    const task = e.target.closest("li.Menu-item");
    let taskNumber;
    if (task.classList.contains("disabled") || task.parentElement.classList.contains("Menu")) {
        return;
    }
    taskNumber = parseInt(task.dataset.task);
    switch (taskNumber) {
      case 1:
        HW_20.task1.render();
        break;

      default:
        alert("This task doesn't exist :(");
    }
}

"use strict";

const defaultMenuWork26 = $("#Menu").find('li[data-work="26"]');

const tabletMenuWork26 = $("#Menu--tablet").find('li[data-work="26"]');

defaultMenuWork26.on("click", renderHW_26);

tabletMenuWork26.on("click", renderHW_26);

function createCustomInput({type: type = text, placeholder: placeholder = "", value: value = "", label: label = false, inputClass: inputClass = "CustomInput", name: name, autocomplete: autocomplete = "off", required: required = false}) {
    const inputWrapper = $(document.createElement("div"));
    const activeBar = $(document.createElement("div"));
    let submitText;
    let labelElement;
    let input = $(document.createElement("input"));
    inputWrapper.addClass(inputClass);
    activeBar.addClass(inputClass + "-bar");
    if (type === "submit") {
        input = $(document.createElement("button"));
        submitText = $(document.createElement("span")).appendTo(input);
        submitText.text(value);
        submitText.addClass("CustomInput-submitText");
        input.attr("type", "submit");
        input.addClass("CustomInput-submit");
        input.appendTo(inputWrapper);
        return inputWrapper;
    }
    if (label) {
        labelElement = $(document.createElement("span")).addClass(inputClass + "-label").text(label).appendTo(inputWrapper);
    }
    input.appendTo(inputWrapper);
    input.addClass(inputClass + "-input");
    input.attr("placeholder", placeholder);
    input.attr("type", type);
    input.attr("autocomplete", autocomplete);
    input.attr("value", value);
    input.on({
        focus: () => inputWrapper.addClass("is-focused"),
        blur: () => inputWrapper.removeClass("is-focused"),
        keyup: () => {
            if (input.val().length) {
                inputWrapper.addClass("is-filled");
            } else {
                inputWrapper.removeClass("is-filled");
            }
        }
    });
    activeBar.appendTo(inputWrapper);
    if (typeof name === "string") {
        input.attr("name", name);
    } else {
        throw new Error("Input TypeError: missing required name parameter");
    }
    if (required) {
        input.attr("_required", "");
    }
    return inputWrapper;
}

function renderHW_26(e) {
    const task = e.target.closest("li.Menu-item");
    let taskNumber;
    if (task.classList.contains("disabled") || task.parentElement.classList.contains("Menu")) {
        return;
    }
    taskNumber = parseInt(task.dataset.task);
    switch (taskNumber) {
      case 1:
        HW_26.task1.render();
        break;

      default:
        alert("This task doesn't exist :(");
    }
}

class SnackBar {
    constructor({name: name, timeout: timeout = true, progressbar: progressbar = true, keepAlive: keepAlive = 4e3, confirm: confirm = true, resolveText: resolveText = "resolve", rejectText: rejectText = "reject", message: message = [ "Default snackbar message" ]}) {
        const snackbar = $(document.createElement("div"));
        const snackbarWrapper = $(document.createElement("div")).appendTo(snackbar);
        let snackbarMessage;
        let buttonWrapper;
        let rejectButton;
        let resolveButton;
        let progressBar;
        this.timeout = timeout;
        this.keepAlive = keepAlive;
        this._snackbar = snackbar;
        snackbar.addClass("Snackbar");
        snackbarWrapper.addClass("Snackbar-wrapper");
        message.forEach((text, index) => {
            snackbarMessage = $(document.createElement("p")).appendTo(snackbarWrapper);
            snackbarMessage.addClass("Snackbar-message");
            snackbarMessage.text(text);
        });
        if (name && typeof name === "string") {
            snackbar.attr("data-snackbar", name);
        }
        if (confirm) {
            buttonWrapper = $(document.createElement("div")).appendTo(snackbarWrapper);
            rejectButton = $(document.createElement("button")).appendTo(buttonWrapper);
            resolveButton = $(document.createElement("button")).appendTo(buttonWrapper);
            buttonWrapper.addClass("Snackbar-buttonWrapper");
            resolveButton.addClass("Button Button--snackbarResolve");
            rejectButton.addClass("Button Button--snackbarReject");
            resolveButton.text(resolveText);
            rejectButton.text(rejectText);
            this._resolveButton = resolveButton;
            this._rejectButton = rejectButton;
            resolveButton.on("click", this.hide.bind(this));
            rejectButton.on("click", this.hide.bind(this));
        }
        if (progressbar) {
            progressBar = $(document.createElement("div")).appendTo(snackbarWrapper);
            progressBar.addClass("Snackbar-progressBar");
            this.progressBar = progressBar;
        }
    }
    show() {
        const self = this;
        this._snackbar.addClass("is-active");
        if (this.progressBar) {
            this.progressBar.css("transition", `width ${this.keepAlive || 4e3}ms linear`).css("width", "0");
            this.progressBar.one("transitionend", e => {
                e.stopPropagation();
                self.hide();
            });
        }
        if (this.timeout && this.progressBar === undefined) {
            setTimeout(this.hide, this.keepAlive);
        }
    }
    hide() {
        const self = this;
        this._snackbar.removeClass("is-active");
        if (this.progressBar !== undefined) {
            this._snackbar.one("transitionend", () => {
                self.progressBar.attr("style", "");
            });
        }
    }
}

class EventEmitter {
    constructor() {
        this._events = {};
    }
    on(event, listener, context) {
        if (context === undefined) {
            throw new Error("EventEmiter TypeError: missing required context parameter");
        }
        if (typeof context !== "object") {
            throw new Error("EventEmiter InputError: required context parameter has invalid type");
        }
        (this._events[event] || (this._events[event] = [])).push(listener.bind(context));
    }
    emit(event, ...args) {
        if (!this._events[event]) {
            throw new Error("Emitter error, called event hasn't registered handlers");
        }
        this._events[event].forEach(listener => listener.apply(null, args));
    }
}

class StudentsModel extends EventEmitter {
    constructor(students = []) {
        super();
        this._students = students;
        let uniqueID = 0;
        this.constructor.generateUniqueId = function() {
            return uniqueID++;
        };
    }
    get studentsList() {
        return this._students;
    }
    uploadData(xhr) {
        if (typeof xhr === "string") {
            $.ajax({
                url: xhr,
                method: "GET",
                context: this,
                success: response => {
                    response.forEach(student => {
                        this.addStudent(student);
                    });
                },
                error: error => {
                    console.log(error);
                }
            });
        }
    }
    addStudent(student) {
        student._studentId = this.constructor.generateUniqueId();
        this._students.push(student);
        this.emit("studentAdded", student);
    }
    deleteStudent(id) {
        const studentsList = this._students;
        let i;
        for (i = 0; i < studentsList.length; i++) {
            if (studentsList[i]._studentId === id) {
                studentsList.splice(i, 1);
                this.emit("studentDeleted", id);
                return;
            }
        }
        throw new Error("Model ReferenceError: reference to a non-existent student ID");
    }
}

class StudentsView extends EventEmitter {
    constructor() {
        super();
        this._elements = {};
        this._icons = {};
        this._timeouts = {};
        this._confirms = {};
        this._elements.form = this.constructor.createAddForm();
        this._elements.table = this.constructor.createTable.call(this);
        this._icons.edit = $('<svg xmlns="http://www.w3.org/2000/svg" width="20px" viewBox="0 0 55.25 55.25"> <path d="M52.618 2.631c-3.51-3.508-9.219-3.508-12.729 0L3.827 38.693c-.017.017-.027.038-.042.056-.021.024-.039.05-.058.076a.972.972 0 0 0-.125.239c-.009.026-.022.049-.029.075l-.012.03-3.535 14.85a.991.991 0 0 0-.022.202c0 .013-.004.025-.004.038a.995.995 0 0 0 .095.403c.049.107.11.21.196.296a1.006 1.006 0 0 0 .938.266l14.85-3.535c.027-.006.051-.021.077-.03a.985.985 0 0 0 .3-.162c.024-.019.049-.033.072-.054.008-.008.018-.012.026-.02L52.617 15.36c3.51-3.51 3.51-9.22.001-12.729zm-1.414 1.414c2.488 2.489 2.7 6.397.65 9.137l-9.787-9.787c2.741-2.05 6.649-1.838 9.137.65zm-4.95 14.85l-9.9-9.9 1.414-1.414 9.9 9.9-1.414 1.414zM4.961 50.288a.999.999 0 0 0-1.414 0l-.757.757 2.554-10.728 4.422-.491-.569 5.122c-.004.038.01.073.01.11 0 .038-.014.072-.01.11.004.033.021.06.028.092a1.016 1.016 0 0 0 .245.473c.048.051.1.094.157.134.045.031.088.06.138.084.066.031.135.049.207.066.038.009.069.03.108.035a.982.982 0 0 0 .109.006h.004a.995.995 0 0 0 .109-.006l5.122-.569-.491 4.422-10.729 2.554.757-.757a1 1 0 0 0 0-1.414zm12.55-5.479L39.889 22.43a.999.999 0 1 0-1.414-1.414L16.097 43.395l-4.773.53.53-4.773 22.38-22.378a.999.999 0 1 0-1.414-1.414L10.44 37.738l-3.183.354L34.94 10.409l9.9 9.9-27.683 27.683.354-3.183zm31.571-28.742l-9.9-9.9 1.415-1.415 9.9 9.9-1.415 1.415z" data-original="#000000" data-old_color="#ffffff" fill="#fff"/> </svg>');
        this._icons.delete = $('<svg xmlns="http://www.w3.org/2000/svg" width="20px" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 774.266 774.266" style="enable-background:new 0 0 774.266 774.266;" xml:space="preserve"><g><g> <g> <path d="M640.35,91.169H536.971V23.991C536.971,10.469,526.064,0,512.543,0c-1.312,0-2.187,0.438-2.614,0.875 C509.491,0.438,508.616,0,508.179,0H265.212h-1.74h-1.75c-13.521,0-23.99,10.469-23.99,23.991v67.179H133.916 c-29.667,0-52.783,23.116-52.783,52.783v38.387v47.981h45.803v491.6c0,29.668,22.679,52.346,52.346,52.346h415.703 c29.667,0,52.782-22.678,52.782-52.346v-491.6h45.366v-47.981v-38.387C693.133,114.286,670.008,91.169,640.35,91.169z M285.713,47.981h202.84v43.188h-202.84V47.981z M599.349,721.922c0,3.061-1.312,4.363-4.364,4.363H179.282 c-3.052,0-4.364-1.303-4.364-4.363V230.32h424.431V721.922z M644.715,182.339H129.551v-38.387c0-3.053,1.312-4.802,4.364-4.802 H640.35c3.053,0,4.365,1.749,4.365,4.802V182.339z" data-original="#000000" class="active-path" data-old_color="#ffffff" fill="#ffffff"/> <rect x="475.031" y="286.593" width="48.418" height="396.942" data-original="#000000" class="active-path" data-old_color="#ffffff" fill="#ffffff"/> <rect x="363.361" y="286.593" width="48.418" height="396.942" data-original="#000000" class="active-path" data-old_color="#ffffff" fill="#ffffff"/> <rect x="251.69" y="286.593" width="48.418" height="396.942" data-original="#000000" class="active-path" data-old_color="#ffffff" fill="#ffffff"/> </g> </g></g> </svg>');
        let _isChange = false;
        this.getStateChange = function() {
            return _isChange;
        };
        this.setStateChange = function(boolean) {
            if (typeof boolean === "boolean") {
                _isChange = boolean;
            } else {
                throw Error("Viewmodel: input error, state must be boolean");
            }
        };
    }
    get getStudentsFormElement() {
        return this._elements.form;
    }
    get getStudentsTableElement() {
        return this._elements.table;
    }
    renderForm(container) {
        let containerElement;
        if (container instanceof HTMLElement) {
            $(this._elements.form).appendTo(container);
        } else {
            containerElement = $(container);
            if (containerElement.length) {
                $(this._elements.form).appendTo(containerElement.length === 1 ? containerElement : document.querySelector(container));
            }
        }
        this.constructor.enableFormActions.call(this);
    }
    renderTable(container) {
        let containerElement;
        if (container instanceof HTMLElement) {
            $(this._elements.table).appendTo(container);
            return;
        }
        containerElement = $(container);
        if (containerElement.length) {
            $(this._elements.table).appendTo(containerElement.length === 1 ? containerElement : document.querySelector(container));
        }
    }
    addStudent(studentObj) {
        clearTimeout(this._timeouts.addStudent);
        const newStudentTR = this.constructor.createStudentTR.call(this, studentObj);
        this._elements.list.prepend(newStudentTR);
        this._timeouts.addStudent = setTimeout(this.constructor.updateIndexes.call(this), 100);
        this.setStateChange(false);
    }
    removeStudent(index) {
        this._deletingStudent.remove();
        this.constructor.updateStudentsIndexes.call(this);
        this.setStateChange(false);
    }
    static enableFormActions() {
        this._elements.form.submit(e => {
            e.preventDefault();
            if (this.getStateChange()) {
                return;
            } else {
                this.setStateChange(true);
            }
            this.emit("addStudentRequest", $(this._elements.form).serializeArray());
        });
    }
    static createAddForm() {
        const form = $("<form/>", {
            method: "POST",
            class: "Task-addStudentForm"
        });
        const inputs = [ {
            label: "Name",
            type: "text",
            name: "name",
            required: true
        }, {
            label: "Age",
            type: "text",
            name: "age",
            required: true
        }, {
            label: "Specialization",
            type: "text",
            name: "specialization",
            required: true
        }, {
            label: "Studying year",
            type: "text",
            name: "year",
            required: true
        }, {
            label: "Website",
            type: "text",
            name: "website",
            required: true
        }, {
            label: "Phone number",
            type: "text",
            name: "phone",
            required: true
        }, {
            type: "submit",
            value: "Add"
        } ];
        const row = $("<div/>").addClass("row").appendTo(form);
        let mediaContainer;
        inputs.forEach(inputOptions => {
            mediaContainer = $(document.createElement("div")).appendTo(row);
            mediaContainer.addClass("cell-4");
            createCustomInput(inputOptions).appendTo(mediaContainer);
        });
        mediaContainer.removeClass("cell-4").addClass("cell-12");
        return form;
    }
    static createTable() {
        const table = $("<table>", {
            class: "Task-table"
        });
        const thead = $(document.createElement("thead")).appendTo(table);
        this._elements.list = $(document.createElement("tbody")).appendTo(table);
        const tr = $(document.createElement("tr")).appendTo(thead);
        const columnTitles = [ "Select", "Index", "Name", "Age", "Specialization", "Year of university", "Website", "Phone", "Edit", "Delete" ];
        let th;
        columnTitles.forEach(title => {
            th = $("<th/>", {
                text: title
            }).appendTo(tr);
        });
        return table;
    }
    static createStudentTR(studentObj) {
        const self = this;
        const tr = $(document.createElement("tr"));
        const editIcon = this._icons.edit.clone().on("click", () => {
            self.constructor.clickEditIcon.call(self, tr);
        });
        const deleteIcon = this._icons.delete.clone().on("click", () => {
            self.constructor.clickDeleteIcon.call(self, tr);
        });
        let td = $("<td/>", {
            "data-column": "select"
        }).appendTo(tr);
        let key;
        td.append($("<input/>", {
            type: "checkbox",
            name: "select"
        }));
        td = $("<td/>").appendTo(tr)[0].cellType = "index";
        for (key in studentObj) {
            if (studentObj.hasOwnProperty(key) && !~key.indexOf("_")) {
                td = $("<td/>", {
                    text: studentObj[key]
                }).appendTo(tr);
                td[0].cellType = "" + key;
            } else {
                tr[0][key] = studentObj[key];
            }
        }
        td = $("<td/>").appendTo(tr);
        td[0].cellType = "editButton";
        td.append(editIcon);
        td = $("<td/>").appendTo(tr);
        td[0].cellType = "deleteButton";
        td.append(deleteIcon);
        return tr;
    }
    static updateIndexes() {
        const rows = this._elements.list.children();
        rows.each((index, row) => {
            $(row).children().each((index, cell) => {
                if (cell.cellType === "index") {
                    $(cell).text(row.rowIndex);
                    return false;
                }
            });
        });
    }
    static clickEditIcon(tr) {
        if (this.getStateChange()) {
            return;
        } else {
            this.setStateChange(true);
        }
        this.constructor.enableNoteEditing.call(this, tr);
    }
    static clickDeleteIcon(tr) {
        if (this.getStateChange()) {
            return;
        }
        const uniqueStudentId = tr[0]._studentId;
        this._deletingStudent = tr;
        this.constructor.showDeleteConfirm.call(this, uniqueStudentId);
    }
    static updateStudentsIndexes() {
        const rows = this._elements.list.children();
        const indexesData = rows.find("[data-column=index]");
        indexesData.each((index, el) => {
            $(el).text(index + 1);
        });
    }
    static enableNoteEditing(tr) {
        this._tempNoteCopy = $(tr).clone();
        let input;
        let inputText;
        const columnsForEdit = [ "name", "age", "specialization", "year", "website", "phone" ];
        $(tr).children().each((index, column) => {
            column = $(column);
            if (columnsForEdit.includes(column.data("column"))) {
                column.addClass("is-editing");
                input = $(document.createElement("input"));
                input.val(column.text());
                input.width(column.width());
                input.height(column.height());
                column.text("");
                input.appendTo(column);
            }
        });
        this.constructor.showEditingConfirm.call(this, tr);
    }
    static disableNoteEditing(tr) {
        if (this._tempNoteCopy === undefined) {
            throw Error("Viewmodel reference error: row temp copy is not defined");
        }
        $(tr).replaceWith(this._tempNoteCopy);
        this.setStateChange(false);
    }
    static showEditingConfirm(tr) {
        let saveChangesPopup = this._confirms.editStudent;
        if (saveChangesPopup === undefined) {
            saveChangesPopup = new SnackBar({
                name: "saveStudentsChanges",
                keepAlive: false,
                timeout: false,
                message: [ "save changes?" ],
                confirm: true,
                progressbar: false,
                resolveText: "Do it",
                rejectText: "No, go back"
            });
            this._confirms.editStudent = saveChangesPopup;
            $(document.body).append(saveChangesPopup._snackbar);
            saveChangesPopup._resolveButton.on("click", () => this.emit("editStudentRequest", index));
            saveChangesPopup._rejectButton.on("click", () => {
                this.constructor.disableNoteEditing.call(this, tr);
            });
        }
        setTimeout(saveChangesPopup.show.bind(saveChangesPopup), 10);
    }
    static showDeleteConfirm(id) {
        let deletePopup = this._confirms.removeStudent;
        if (deletePopup === undefined) {
            deletePopup = new SnackBar({
                name: "deleteStudentNote",
                timeout: false,
                keepAlive: 5e3,
                message: [ "Are you sure?" ],
                confirm: true,
                resolveText: "Delete",
                rejectText: "Cancel"
            });
            deletePopup._resolveButton.on("click", () => {
                this.setStateChange(true);
                this.emit("deleteStudentRequest", id);
            });
            this._confirms.removeStudent = deletePopup;
            $(document.body).append(deletePopup._snackbar);
        }
        setTimeout(deletePopup.show.bind(deletePopup), 10);
    }
}

class StudentController {
    constructor(model, view) {
        this._model = model;
        this._view = view;
        view.on("addStudentRequest", this.constructor.sendParsedStudent, this);
        view.on("deleteStudentRequest", model.deleteStudent, model);
        model.on("studentAdded", view.addStudent, view);
        model.on("studentDeleted", view.removeStudent, view);
    }
    static sendParsedStudent(serializedData) {
        const studentObj = this.constructor.parseData(serializedData);
        this._model.addStudent(studentObj);
    }
    static parseData(data) {
        const studentObj = {};
        let i;
        let key;
        let value;
        for (i = 0; i < data.length; i++) {
            key = data[i].name;
            value = data[i].value;
            if (key === "" || value === "") {
                throw new Error("Controller Error: failure during data parse ");
            }
            studentObj[key] = value;
        }
        return studentObj;
    }
}

const studentsModel = new StudentsModel();

const studentsView = new StudentsView();

const studentsController = new StudentController(studentsModel, studentsView);

new Promise(resolve => {
    studentsView.renderForm("#123");
    studentsView.renderTable("#123");
    resolve();
}).then(() => {
    studentsModel.uploadData("http://localhost:63342/Layout_sass/dist/studentsBase.json");
});

"use strict";

const defaultMenuWork28 = $("#Menu").find('li[data-work="28"]');

defaultMenuWork28.on("click", renderHW_28);

const exposureMediator = function() {
    const subscribers = {};
    return {
        on: function(event, callback) {
            subscribers[event] = subscribers[event] || new Set();
            subscribers[event].add(callback);
        },
        off: function(event, callback) {
            if (subscribers[event]) {
                subscribers[event].delete(callback);
            } else {
                throw Error(`Reference Error: event "${event}" hasn't exist`);
            }
        },
        emit: function(event, ...rest) {
            if (subscribers[event]) {
                subscribers[event].forEach(callback => {
                    callback(...rest);
                });
            } else {
                throw Error(`Reference Error: event "${event}" hasn't exist`);
            }
        }
    };
}();

const ExposureMenu = function(isVertical) {
    const exposureMenu = $(document.createElement("ul")).addClass("ExposureMenu");
    const exposureMenuTitles = [ "Cats", "Dogs", "Rabbits" ];
    const exposureMenuSubItems = [ [ {
        name: "Hellblade",
        imgSrc: "images/Exposure1_1.jpg"
    }, {
        name: "Aries",
        imgSrc: "images/Exposure1_2.jpg"
    }, {
        name: "Van Gogh",
        imgSrc: "images/Exposure1_3.jpg"
    } ], [ {
        name: "Seal",
        imgSrc: "images/Exposure2_1.jpg"
    }, {
        name: "Optical prism",
        imgSrc: "images/Exposure2_2.jpg"
    }, {
        name: "Pond",
        imgSrc: "images/Exposure2_3.jpg"
    } ], [ {
        name: "Raccon Rocket",
        imgSrc: "images/Exposure3_1.jpg"
    }, {
        name: "Disneyland",
        imgSrc: "images/Exposure3_2.jpg"
    }, {
        name: "Pirate",
        imgSrc: "images/Exposure3_3.jpg"
    } ] ];
    let exposureMenuItemContainer;
    let exposureMenuItem;
    let exposureSubMenu;
    let exposureSubMenuItem;
    let exposureSubMenuItemContainer;
    this._menuItems = {};
    this._menuEl = exposureMenu;
    if (isVertical) {
        exposureMenu.addClass("ExposureMenu--vertical");
    }
    exposureMenuTitles.forEach((title, index) => {
        exposureMenuItemContainer = $(document.createElement("li")).addClass("ExposureMenu-item").appendTo(exposureMenu);
        exposureMenuItem = $(document.createElement("span")).addClass("ExposureMenu-itemText").text(title).appendTo(exposureMenuItemContainer);
        exposureSubMenu = $(document.createElement("ul")).addClass("ExposureMenu-subMenu").appendTo(exposureMenuItemContainer);
        const itemName = exposureMenuItem.text();
        this._menuItems[exposureMenuItem.text()] = exposureMenuItemContainer;
        exposureMenuItem.on("click", () => {
            exposureMediator.emit("toggleSubmenu", itemName);
        });
        exposureMenuSubItems[index].forEach(item => {
            exposureSubMenuItemContainer = $(document.createElement("li")).addClass("ExposureMenu-item").appendTo(exposureSubMenu);
            exposureSubMenuItem = $(document.createElement("span")).addClass("ExposureMenu-itemText").text(item.name).appendTo(exposureSubMenuItemContainer);
            exposureSubMenuItem[0].imageSrc = item.imgSrc;
            exposureSubMenuItem.on("click", () => {
                exposureMediator.emit("changePicture", item.name, item.imgSrc);
            });
        });
    });
    exposureMediator.on("toggleSubmenu", this.toggleSubmenu.bind(this));
};

ExposureMenu.prototype = {
    constructor: ExposureMenu,
    render: function(container) {
        let containerElement;
        if (container instanceof HTMLElement) {
            $(this._menuEl).appendTo(container);
            return;
        }
        if (container instanceof jQuery) {
            this._menuEl.appendTo(container);
            return;
        }
        containerElement = $(container);
        if (containerElement.length) {
            $(this._menuEl).appendTo(containerElement.length === 1 ? containerElement : document.querySelector(container));
        }
    },
    toggleSubmenu: function(menu) {
        let submenuTarget;
        for (let key in this._menuItems) {
            if (key !== menu) {
                $(this._menuItems[key]).find("ul").slideUp("fast");
            } else {
                submenuTarget = $(this._menuItems[key]).find("ul");
            }
        }
        submenuTarget.slideToggle({
            duration: 300,
            start: () => submenuTarget.css("display", "flex")
        });
    }
};

const ExposureBlock = function() {
    const exposureBlock = $(document.createElement("div")).addClass("Exposure");
    const exposureTitle = $(document.createElement("h3")).addClass("Exposure-title").text("Hellblade").appendTo(exposureBlock);
    const exposureImageContainer = $(document.createElement("div")).addClass("Exposure-imageContainer").appendTo(exposureBlock);
    const exposureImage = $(document.createElement("img")).attr("src", "images/Exposure1_1.jpg").addClass("Exposure-image").appendTo(exposureImageContainer);
    this._exposureEl = exposureBlock;
    this._exposureTitle = exposureTitle;
    this._exposurePicture = exposureImage;
    exposureMediator.on("changePicture", this.update.bind(this));
};

ExposureBlock.prototype = {
    constructor: ExposureBlock,
    render: function(container) {
        let containerElement;
        if (container instanceof HTMLElement) {
            $(this._exposureEl).appendTo(container);
            return;
        }
        if (container instanceof jQuery) {
            this._exposureEl.appendTo(container);
            return;
        }
        containerElement = $(container);
        if (containerElement.length) {
            $(this._exposureEl).appendTo(containerElement.length === 1 ? containerElement : document.querySelector(container));
        }
    },
    update: function(title, src) {
        $(this._exposureTitle).text(title);
        $(this._exposurePicture).attr("src", src);
    }
};

function renderHW_28(e) {
    const task = e.target.closest("li.Menu-item");
    let taskNumber;
    if (task.classList.contains("disabled") || task.parentElement.classList.contains("Menu")) {
        return;
    }
    taskNumber = parseInt(task.dataset.task);
    switch (taskNumber) {
      case 1:
        HW_28.task1.render();
        break;

      default:
        alert("This task doesn't exist :(");
    }
}

const HW_28 = {
    task1: {
        render() {
            HW_28.clearContentContainer();
            const renderArea = $("#Content-area");
            let task;
            if (this.taskItem) {
                renderArea.append(this.taskItem);
                return;
            }
            const taskContainer = $(document.createElement("div")).addClass("Task-container Task-container--exposure").appendTo(renderArea);
            const exposure = new ExposureBlock();
            const horizontalMenu = new ExposureMenu(false);
            const verticalMenu = new ExposureMenu(true);
            horizontalMenu.render(taskContainer);
            exposure.render(taskContainer);
            verticalMenu.render(taskContainer);
            this.taskItem = taskContainer;
        }
    },
    clearContentContainer: function() {
        const renderArea = document.getElementById("Content-area");
        while (renderArea.firstChild) {
            renderArea.removeChild(renderArea.firstChild);
        }
    }
};

"use strict";

function toggleSidebar(e) {
    const sidebarBtn = document.querySelector(".Button-menuWrapper");
    const sidebar = document.querySelector("aside.Sidebar");
    const tabletMenu = document.querySelector(".Menu--tablet");
    const main = document.getElementById("Main");
    if (sidebarBtn.classList.contains("active") && e.target !== sidebarBtn && !e.target.closest("aside.Sidebar") && !e.target.closest("ul.Menu--tablet")) {
        if (window.innerWidth > 768) {
            main.parentElement.classList.toggle("cell-9");
            main.parentElement.classList.toggle("cell-12");
            main.classList.remove("perspective");
            sidebar.parentElement.classList.toggle("cell-3");
            sidebar.parentElement.classList.toggle("cell-none");
            sidebarBtn.classList.remove("active");
        } else {
            tabletMenu.classList.remove("active");
            main.classList.remove("perspective");
            sidebarBtn.classList.remove("active");
        }
        return;
    }
    if (e.target.closest(".Button-menuWrapper")) {
        sidebarBtn.classList.toggle("active");
        if (window.innerWidth > 768) {
            main.parentElement.classList.toggle("cell-9");
            main.parentElement.classList.toggle("cell-12");
            main.classList.toggle("perspective");
            sidebar.parentElement.classList.toggle("cell-3");
            sidebar.parentElement.classList.toggle("cell-none");
        } else {
            tabletMenu.classList.toggle("active");
            main.classList.toggle("perspective");
        }
    }
}

window.addEventListener("click", toggleSidebar);

particlesJS("particles-js", {
    particles: {
        number: {
            value: 80,
            density: {
                enable: true,
                value_area: 790
            }
        },
        color: {
            value: "#ffffff"
        },
        shape: {
            type: "circle",
            stroke: {
                width: 0,
                color: "#000000"
            },
            polygon: {
                nb_sides: 3
            },
            image: {
                src: "img/github.svg",
                width: 100,
                height: 100
            }
        },
        opacity: {
            value: .5,
            random: false,
            anim: {
                enable: false,
                speed: 1,
                opacity_min: .1,
                sync: false
            }
        },
        size: {
            value: 3,
            random: true,
            anim: {
                enable: false,
                speed: 40,
                size_min: .1,
                sync: false
            }
        },
        line_linked: {
            enable: true,
            distance: 150,
            color: "#ffffff",
            opacity: .4,
            width: 1
        },
        move: {
            enable: true,
            speed: 4.810236182596568,
            direction: "none",
            random: false,
            straight: false,
            out_mode: "bounce",
            bounce: false,
            attract: {
                enable: false,
                rotateX: 1523.2414578222467,
                rotateY: 1282.7296486924183
            }
        }
    },
    interactivity: {
        detect_on: "canvas",
        events: {
            onhover: {
                enable: false,
                mode: "repulse"
            },
            onclick: {
                enable: false,
                mode: "bubble"
            },
            resize: true
        },
        modes: {
            grab: {
                distance: 400,
                line_linked: {
                    opacity: 1
                }
            },
            bubble: {
                distance: 146.17389821424212,
                size: 16.241544246026905,
                duration: .3248308849205381,
                opacity: .46288401101176674,
                speed: 3
            },
            repulse: {
                distance: 200,
                duration: .4
            },
            push: {
                particles_nb: 4
            },
            remove: {
                particles_nb: 2
            }
        }
    },
    retina_detect: false
});

"use strict";

document.querySelector("#Menu").addEventListener("click", renderSublist);

document.querySelector("#Menu--tablet").addEventListener("click", renderSublist);

function renderSublist(e) {
    let li = e.target.closest("li.Menu-item");
    if (li.parentElement.classList.contains("Menu-sublist") || li.classList.contains("disabled")) {
        return;
    }
    li.classList.toggle("active");
}